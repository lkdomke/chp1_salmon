---
title: "chp1_sal_and_vegetation"
author: "Lia Domke"
date: "9/3/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

For chapter 1 I'm focusing on salmon in nearshore habitats. Based on the brief lit review in Lefcheck 2019 and their subsequent analysis that did *not* include any juvenile fish density comparison surveys from Alaska, I'm curious to look at salmon density and composition (which sp present) between different nearshore habitats (unvegtation: bedrock/sand-gravel) (vegetated: eelgrass/understory kelp)
Steps to do this:
1. subset noaa data by only sites that sampled different adjacent habitats around the same time. 

2. Look into the timing of the salmon catch, include on earlier summer catches. 

3. Include biomass too, calculate biomass for each of the salmon species caught based on the fork length. 

# Libraries
```{r libraries}
library(tidyverse)
require(leaflet)
require(rgdal)
```

# Data
```{r data}
#noaa <- read.csv("../APECS Master repository/APECS Master repo/ALL_DATA/Lia_fish/noaa_seine_clean_dist.csv", 
                 stringsAsFactors = FALSE, header = TRUE)

noaa <- read.csv("../APECS Master repository/APECS Master repo/ALL_DATA/Lia_fish/noaa_seak_fish_atlas_CLEAN_LD.csv")

fishLW <- read.csv("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3A42b3eee9-f6a3-4169-99ef-ed388f46d172", stringsAsFactors = FALSE, header = TRUE)
```

# Cleaning
Minor cleaning to make sure we're only looking at Southeast data and that there are 0's for sites were we didn't catch any salmon
Subset data to include only salmon data
```{r cleaning}
# do this now to prevent having to do it 100 times below
noaa$SiteID <- as.character(noaa$SiteID)
noaa$EventID <- as.character(noaa$EventID)

# double check to make sure we're only looking at SEAK and BSEINE gear
seak_fish <- noaa %>%
  filter(Region == "southeastern Alaska", Gear == "BSEINE") %>%
  rename(Latitude = Lat1, Longitude = Long1)

# Extract environmental only data 
env <- seak_fish %>%
  dplyr::select(SiteID, EventID, Date, Year, Temp, Salinity, Habitat, Latitude, Longitude) %>%
  distinct()

# location data
loc <- seak_fish %>%
  #rename(Location = Location.y, SubLocale = SubLocale.y) %>%
  dplyr::select(SiteID, EventID, Date, Year, Gear, Region, Locale, Location, SubLocale) %>%
  distinct()

# Calculate fish abundance, can later sum this if interested in only abundance
str(seak_fish)
seak_fish$abundance <- as.numeric(ifelse(is.na(seak_fish$Length), paste(seak_fish$Unmeasured), 1)) 


# extract full list of site info (SiteID, EventID)
SiteID <- unique(seak_fish$SiteID) # 303 unique sites (updated #396)
EventID <- unique(seak_fish$EventID) # 615 total seines done (updated #798)
Site_info <- unique(subset(seak_fish, select = c("SiteID", "EventID", "Latitude", "Longitude", "Locale", "Habitat"))) # all unique seines
```

# Data prep
Want to run a loop so that, for each species caught, we can estimate fork length for the unmeausred fish but also estimate biomass for both. 
```{r}
# make sure columns have appropriate character type
glimpse(seak_fish)
seak_fish$Unmeasured <- as.numeric(seak_fish$Unmeasured)
seak_fish$EventID <- as.character(seak_fish$EventID)

# only need salmon, otherwise there are a lot of fish we don't have length-weight info for:
seak_sal <- seak_fish %>%
  filter(taxon != "invertebrate") %>%
  filter(SpCode == "SALCHUM" | SpCode == "SALCOHO"| 
      SpCode == "SALSOCK"| SpCode == "SALCHIN"
      | SpCode == "SALPINK")

# How many salmon total did we catch? 
pre_loop <- seak_sal %>% 
  dplyr::summarise(count = sum(abundance)) # (# updated seines 149329)

pre_site_sp <- seak_sal %>%
  group_by(SiteID, EventID, SpCode) %>%
  dplyr::summarise(pre_count = sum(abundance))
## Separate measured and unmeasured fish

fish.m <- seak_sal %>%
  filter(taxon != "invertebrate") %>% # make sure you're only looking at fish
  filter(Length != "NA")


fish.um <- seak_sal %>%
  filter(taxon != "invertebrate") %>% 
  filter(Unmeasured != "estimate") %>% # assume that infield estimates are accurate
  filter(is.na(Length)) 

## Assign lengths to unmeasured fish
#' When beach seining we only measured the first 30 individuals of a species, and counted the rest. 
#' We can use the measured fishes to create a distribution from which we can assign 
#' lengths to the unmeasured fishes.

#' Assign lengths to unmeasured fish based on sampled distribution.
#'  This assignment should happen at the EventID level. i.e. use the distribution of fishes at a 
#'  EventID to assign unmeasured fishes at that EventID. 

#' We will assume the least and just use the sampled proportions to assign lenghts to unmeasured fish. 
# Exclued fishes that do not have a measured counterpart. These were insantces when we 
# tossed a fish without knowing what it was other than it was a sculpin thing


# figure out which species at sites that there is not a measured conterpart 
#  x <- fish.um %>%
#  group_by(EventID, SpCode) %>%
#  anti_join(fish.m, by = c("EventID", "SpCode")) # clearly there are lots of situations where during a seine they didn't measure any fish and only counted them--making biomass conversions impossible?

# Which fish do we not have length-width conversions?
y <- fish.um %>%
  anti_join(fishLW, by = c("Sp_ScientificName" = "species_scientific")) # Just sockeye salmon, not on fish base for length to weight conversions, very few sockeye salmon were caught so we might have to drop these fish from the analysis. Within the prince of wales area this is 1 fish. 

# remove the sockeye, we'll try and go ahead and do the conversions for the fish we have info for
fish.um.redu <- fish.um %>%
  filter(SpCode != "SALSOCK") #%>%
  #anti_join(x, by = c("EventID", "SpCode")) # this removes the instances that we didn't have measured counterparts for the measured data
```

# Subset where not enough fish measured
Before we run the loop to extrapolate lengths, we should make sure that there are enough measured fish to be able to extrapolate to the unmeasured ones (n = 30). 
```{r}
# make a loop
f <- data.frame() # dataframe to put the ones that meet the requirement

for(s in unique(fish.um.redu$EventID)){
  df.m <- fish.m %>%
    filter(EventID == s)
  df.um <- fish.um.redu %>%
    filter(EventID == s)
  for(i in unique(df.um$SpCode)){
    samp <- df.m %>%
      filter(SpCode == i)
    cond <- length(samp$Length) > 30
    dat1 <- data.frame(EventID = s, SpCode = i, keep = cond)
    f <- rbind(f, dat1)
  }
} # dang thats a lot that don't make the condition

# Create new df for adding back into the data later
excluded.fish <- left_join(fish.um.redu, f) %>%
  filter(keep == FALSE)
  
  
# Remove the sites that don't have enough unmeasured counterparts

fish.um.redu <- left_join(fish.um.redu, f) %>%
  filter(keep == TRUE)


```

# Length loop!
run the loops!
```{r}
d <- data.frame() # empty dataframe to fill with for loop

for(s in unique(fish.um.redu$EventID)){ # cycle through site by unique seines (EventID)
  dat.m <- fish.m %>% # subset measured data
    filter(EventID == s)
  dat.um <- fish.um.redu %>% #subset unmeasured data
    filter(EventID == s)
  for(i in unique(dat.um$SpCode)){ #cycle through species that are in UNMEASURED data
      samp <- dat.m %>% # create sample from which to make distrubution
        filter(SpCode == i)
      unmeas <- dat.um %>% # isolate unmeasured fish
        filter(SpCode == i) %>%
        dplyr::summarise(unmeas = sum(Unmeasured)) # sums more than one entry of unmeasured at the same site/species
      unmeas <- as.numeric(unmeas$unmeas) # save unmeasured value
      dat <- data.frame(size = as.character(samp$Length))
      dat2 <- dat %>% 
        group_by(size) %>% 
        dplyr::summarise(count = n())
      dat2$prob <- (dat2$count/sum(dat2$count))
      dat2$x <- as.numeric(paste(dat2$size))
      fx <- function(n){ # function derived from limits and probabilities of above
        sample(x = (dat2$x), n, replace = TRUE, prob = dat2$prob)
      }
      dat3 <- data.frame(site = s, sp_code = i, fork_length = fx(unmeas))
      d <- rbind(d, dat3)
    }
}  
```

Add in seperate site/extra information that got dropped from the loop. 
```{r}
fish.site <- unique(seak_fish[,c("SiteID","EventID", "Date", "Mon", "Year", "Gear", "Latitude", "Longitude")])
fish.sp <- unique(seak_fish[,c("Sp_CommonName", "Sp_ScientificName", "SpCode", "taxon")])

# Add site details
d.info <- left_join(d, fish.site, by = c("site" = "EventID")) %>%
  dplyr::rename(EventID = site)
# Add species details
d.info <- left_join(d.info, fish.sp, by = c("sp_code" = "SpCode"))
# Test to make sure it combined properly
test <- anti_join(d.info, d, by = "sp_code")
unique(test$sp_code) # SALCHIN and SALSOCK not included, but thats because they weren't caught... and sockeye were removed
```

Add in the fish that were already measured and the fish there are no cooresponding measured counterparts
```{r}
d.info <- d.info %>%
  dplyr::rename(SpCode = sp_code, Length = fork_length)
# add in measured fish that were used in the loop, but don't appear in the d output dataframe
fish.m.all <- bind_rows(d.info, fish.m)

# add in unmeasured fish that did NOT have a measured counter part and were not included in the loop above
# these are the fish excluded and sockeye salmon 

sal.all <- fish.m.all %>%
  bind_rows(excluded.fish) %>%
  bind_rows(y) %>%
  dplyr::select(-c(X, keep))

# check to make sure we have the same number of salmon we started with (125450, updated 149329)
sal.all$abundance <- as.numeric(ifelse(is.na(sal.all$Length), paste(sal.all$Unmeasured), 1))
sal.all %>%
  dplyr::summarise(sum = sum(abundance)) # woo!

# do an full join, meaning that we're retaining all rows. This should join the salmon sites together and then add in non salmon sites
non_sal <- anti_join(Site_info, sal.all)
fish.all <- full_join(sal.all, non_sal)
```

Okay so now we have a dataframe with information about the salmon that were caught (count numbers) and size (only where measured and where it could be extrapolated). It also has siteID and eventID from all the seines that occured. So we can add in zeros for the sites we didn't catch any salmon. 
BUT because the size info is only partial (salmon weren't measured at every site) Length information should be kept seperate

Create two dataframes, one with abundance one with available length info (so a partial dataset of all the caught fish). 

```{r}
# make sure that abundance column is correct
fish.all$abundance <- as.numeric(ifelse(is.na(fish.all$Length), paste(fish.all$Unmeasured), 1))

fish.count <- fish.all %>%
  dplyr::select(SiteID, EventID, Date, Mon, Year, Gear, Latitude, Longitude, SpCode, Sp_CommonName, 
                Sp_ScientificName, abundance, Locale, Habitat) %>%
  group_by(SiteID, EventID, SpCode) %>%
  dplyr::summarise(abundance = sum(abundance))

# quick checks
fish.all %>%
  dplyr::summarise(post_count = sum(abundance, na.rm = TRUE))

fish_lng <- fish.all %>%
  filter(Length != "NA") # sites where there are no lenght data does NOT mean that no salmon were caught there, just that no salmon were measured there and *might have* been caught. 
```

# Get 0's
For the following purposes we're going to use the `fish.count` dataframe

Calculate 0's for sites no salmon were caught
```{r}
# add back in the site info
fish.counts <- left_join(fish.count, env) %>%
  left_join(loc)

# long --> wide
# This includes ALL species (not just salmon). We'll leave this for now because it matches the
# environmental dataframe. But eventually we'll have to remove the non-salmon species. BUT we want
# retain the 0 where a seine was done but no salmon were caught. 
df_wide <- pivot_wider(fish.counts, id_cols = c(SiteID, EventID, Locale, SubLocale, Date, Year, Latitude, Longitude, Habitat), names_from = SpCode, values_from = abundance) %>%
  dplyr::select(-"NA") %>%
  replace(is.na(.), 0)

# wide -- > long, convserves zeros and site/event ID information

df_long <- pivot_longer(df_wide, cols = c(SALCHIN, SALCOHO, SALPINK, SALCHUM, SALSOCK), names_to = "SpCode", values_to = "abundance")


# REMOVE ALL SEINES WHERE THEY CAUGHT LESS THAN 10 SALMON
# sal_wide <- sal_wide[which(rowSums(sal_wide[,7:11]) > 10),] # this is good to do for nmds analysis
# sal_long <- melt(sal_wide, id = c("SiteID", "EventID", "Date", "Mon", "Season", "Year"), variable.name = "SpCode", value.name = "abundance" )
```

Now we have four dataframes to be working with. 
1. df_wide - salmon abundances for all sites in a wide format
2. df_long - same data as the wide df but long
3. env - environmental data in a wide format
4. loc - location information for each site (included with df_wide and df_long)

# Map
Lets map out the sites so that we can see where the diff sites are location and we can 
```{r map}
# make sure the habitat column is a factor with only 4 levels
fish.counts$Habitat <- as.factor(fish.counts$Habitat)
levels(fish.counts$Habitat)[levels(fish.counts$Habitat)=="Sand-Gravel"] <- "Sand-gravel"
levels(fish.counts$Habitat)[levels(fish.counts$Habitat)=="Surfgrass"] <- "Kelp"

# Prince of Wales Water Polygon
h2o.utm <- readOGR(dsn = "../APECS Master repository/APECS Master repo/ALL_DATA/spatial_data", layer = "POW_water_UTM")
h2o.latlong <- spTransform(h2o.utm, CRS("+init=epsg:4326"))

# Set up icons
icon.hab <- awesomeIcons(icon = "map_pin", 
                          markerColor = ifelse(fish.counts$Habitat == "Kelp", "orange", 
                                               ifelse(fish.counts$Habitat == "Eelgrass", "green",
                                                      ifelse(fish.counts$Habitat == "Bedrock", "gray",
                                                             ifelse(fish.counts$Habitat == "Sand-gravel", "red", "blue")))
                                               ), library = "fa", iconColor = "black")

# Create the map
require(leaflet)
m <- leaflet() %>% 
  addTiles() %>% 
  addPolygons(data = h2o.latlong, stroke = NA, fillColor = "blue", 
                                  fillOpacity = 0.8, group = "POW") %>%
  addAwesomeMarkers(data = fish.counts, ~Longitude, ~Latitude, label = ~EventID, icon = icon.hab)
# require(htmlwidgets)
# saveWidget(m, file="m.html")
m
```

