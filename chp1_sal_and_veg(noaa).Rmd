---
title: "chp1_sal_and_vegetation"
author: "Lia Domke"
date: "9/3/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

For chapter 1 I'm focusing on salmon in nearshore habitats. Based on the brief lit review in Lefcheck 2019 and their subsequent analysis that did *not* include any juvenile fish density comparison surveys from Alaska, I'm curious to look at salmon density and composition (which sp present) between different nearshore habitats (unvegtation: bedrock/sand-gravel) (vegetated: eelgrass/understory kelp)
Steps to do this:
1. subset noaa data by only sites that sampled different adjacent habitats around the same time. 

2. Look into the timing of the salmon catch, include on earlier summer catches. 

3. Include biomass too, calculate biomass for each of the salmon species caught based on the fork length. 

# Libraries
```{r libraries}
library(dplyr)
require(leaflet)
require(rgdal)
library(corrgram)
library(lubridate)
library(tidyr)
library(ggplot2)
```

# Data
```{r data}
# this dataset has the distance from anad stream which is good, but for some reason a couple sites where bedrock was seined there is no distance measurement. 
anad_dist <- read.csv("../APECS Master repository/APECS Master repo/ALL_DATA/Lia_fish/noaa_seine_clean_dist.csv", 
                 stringsAsFactors = FALSE, header = TRUE) 

# use this df for all seine data (as of 9/16/20)
noaa <- read.csv("../APECS Master repository/APECS Master repo/ALL_DATA/Lia_fish/noaa_seak_fish_atlas_CLEAN_LD.csv")

fishLW <- read.csv("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3A42b3eee9-f6a3-4169-99ef-ed388f46d172", stringsAsFactors = FALSE, header = TRUE)
```

# Cleaning
Minor cleaning to make sure we're only looking at Southeast data and that there are 0's for sites were we didn't catch any salmon
Subset data to include only salmon data
```{r cleaning}
# do this now to prevent having to do it 100 times below
noaa$SiteID <- as.character(noaa$SiteID)
noaa$EventID <- as.character(noaa$EventID)

# double check to make sure we're only looking at SEAK and BSEINE gear
seak_fish <- noaa %>%
  dplyr::filter(Region == "southeastern Alaska", Gear == "BSEINE") %>%
  dplyr::rename(Latitude = Lat1, Longitude = Long1)

# Extract environmental only data 
env <- seak_fish %>%
  dplyr::select(SiteID, EventID, Date, Year, Temp, Salinity, Habitat, Latitude, Longitude) %>%
  distinct()

# location data
loc <- seak_fish %>%
  #rename(Location = Location.y, SubLocale = SubLocale.y) %>%
  dplyr::select(SiteID, EventID, Date, Year, Gear, Region, Locale, Location, SubLocale) %>%
  distinct()

# Calculate fish abundance, can later sum this if interested in only abundance
str(seak_fish)
seak_fish$abundance <- as.numeric(ifelse(is.na(seak_fish$Length), paste(seak_fish$Unmeasured), 1)) 


# extract full list of site info (SiteID, EventID)
SiteID <- unique(seak_fish$SiteID) # 303 unique sites (updated #396)
EventID <- unique(seak_fish$EventID) # 615 total seines done (updated #798)
Site_info <- unique(subset(seak_fish, select = c("SiteID", "EventID", "Latitude", "Longitude", "Locale", "Habitat"))) # all unique seines
```

# Data prep
Want to run a loop so that, for each species caught, we can estimate fork length for the unmeausred fish but also estimate biomass for both. 
```{r}
# make sure columns have appropriate character type
glimpse(seak_fish)
seak_fish$Unmeasured <- as.numeric(seak_fish$Unmeasured)
seak_fish$EventID <- as.character(seak_fish$EventID)

# only need salmon, otherwise there are a lot of fish we don't have length-weight info for:
seak_sal <- seak_fish %>%
  filter(taxon != "invertebrate") %>%
  filter(SpCode == "SALCHUM" | SpCode == "SALCOHO"| 
      SpCode == "SALSOCK"| SpCode == "SALCHIN"
      | SpCode == "SALPINK")

# How many salmon total did we catch? 
pre_loop <- seak_sal %>% 
  dplyr::summarise(count = sum(abundance)) # (# updated seines 149329)

pre_site_sp <- seak_sal %>%
  group_by(SiteID, EventID, SpCode) %>%
  dplyr::summarise(pre_count = sum(abundance))
## Separate measured and unmeasured fish

fish.m <- seak_sal %>%
  filter(taxon != "invertebrate") %>% # make sure you're only looking at fish
  filter(Length != "NA")


fish.um <- seak_sal %>%
  filter(taxon != "invertebrate") %>% 
  filter(Unmeasured != "estimate") %>% # assume that infield estimates are accurate
  filter(is.na(Length)) 

## Assign lengths to unmeasured fish
#' When beach seining we only measured the first 30 individuals of a species, and counted the rest. 
#' We can use the measured fishes to create a distribution from which we can assign 
#' lengths to the unmeasured fishes.

#' Assign lengths to unmeasured fish based on sampled distribution.
#'  This assignment should happen at the EventID level. i.e. use the distribution of fishes at a 
#'  EventID to assign unmeasured fishes at that EventID. 

#' We will assume the least and just use the sampled proportions to assign lenghts to unmeasured fish. 
# Exclued fishes that do not have a measured counterpart. These were insantces when we 
# tossed a fish without knowing what it was other than it was a sculpin thing


# figure out which species at sites that there is not a measured conterpart 
#  x <- fish.um %>%
#  group_by(EventID, SpCode) %>%
#  anti_join(fish.m, by = c("EventID", "SpCode")) # clearly there are lots of situations where during a seine they didn't measure any fish and only counted them--making biomass conversions impossible?

# Which fish do we not have length-width conversions?
y <- fish.um %>%
  anti_join(fishLW, by = c("Sp_ScientificName" = "species_scientific")) # Just sockeye salmon, not on fish base for length to weight conversions, very few sockeye salmon were caught so we might have to drop these fish from the analysis. Within the prince of wales area this is 1 fish. 

# remove the sockeye, we'll try and go ahead and do the conversions for the fish we have info for
fish.um.redu <- fish.um %>%
  filter(SpCode != "SALSOCK") #%>%
  #anti_join(x, by = c("EventID", "SpCode")) # this removes the instances that we didn't have measured counterparts for the measured data
```

# Subset where not enough fish measured
Before we run the loop to extrapolate lengths, we should make sure that there are enough measured fish to be able to extrapolate to the unmeasured ones (n = 30). 
```{r}
# make a loop
f <- data.frame() # dataframe to put the ones that meet the requirement

for(s in unique(fish.um.redu$EventID)){
  df.m <- fish.m %>%
    filter(EventID == s)
  df.um <- fish.um.redu %>%
    filter(EventID == s)
  for(i in unique(df.um$SpCode)){
    samp <- df.m %>%
      filter(SpCode == i)
    cond <- length(samp$Length) > 30
    dat1 <- data.frame(EventID = s, SpCode = i, keep = cond)
    f <- rbind(f, dat1)
  }
} # dang thats a lot that don't make the condition

# Create new df for adding back into the data later
excluded.fish <- left_join(fish.um.redu, f) %>%
  filter(keep == FALSE)
  
  
# Remove the sites that don't have enough unmeasured counterparts

fish.um.redu <- left_join(fish.um.redu, f) %>%
  filter(keep == TRUE)


```

# Length loop!
run the loops!
```{r}
d <- data.frame() # empty dataframe to fill with for loop

for(s in unique(fish.um.redu$EventID)){ # cycle through site by unique seines (EventID)
  dat.m <- fish.m %>% # subset measured data
    filter(EventID == s)
  dat.um <- fish.um.redu %>% #subset unmeasured data
    filter(EventID == s)
  for(i in unique(dat.um$SpCode)){ #cycle through species that are in UNMEASURED data
      samp <- dat.m %>% # create sample from which to make distrubution
        filter(SpCode == i)
      unmeas <- dat.um %>% # isolate unmeasured fish
        filter(SpCode == i) %>%
        dplyr::summarise(unmeas = sum(Unmeasured)) # sums more than one entry of unmeasured at the same site/species
      unmeas <- as.numeric(unmeas$unmeas) # save unmeasured value
      dat <- data.frame(size = as.character(samp$Length))
      dat2 <- dat %>% 
        group_by(size) %>% 
        dplyr::summarise(count = n())
      dat2$prob <- (dat2$count/sum(dat2$count))
      dat2$x <- as.numeric(paste(dat2$size))
      fx <- function(n){ # function derived from limits and probabilities of above
        sample(x = (dat2$x), n, replace = TRUE, prob = dat2$prob)
      }
      dat3 <- data.frame(site = s, sp_code = i, fork_length = fx(unmeas))
      d <- rbind(d, dat3)
    }
}  
```

Add in seperate site/extra information that got dropped from the loop. 
```{r}
fish.site <- unique(seak_fish[,c("SiteID","EventID", "Date", "Mon", "Year", "Gear", "Latitude", "Longitude")])
fish.sp <- unique(seak_fish[,c("Sp_CommonName", "Sp_ScientificName", "SpCode", "taxon")])

# Add site details
d.info <- left_join(d, fish.site, by = c("site" = "EventID")) %>%
  dplyr::rename(EventID = site)
# Add species details
d.info <- left_join(d.info, fish.sp, by = c("sp_code" = "SpCode"))
# Test to make sure it combined properly
test <- anti_join(d.info, d, by = "sp_code")
unique(test$sp_code) # SALCHIN and SALSOCK not included, but thats because they weren't caught... and sockeye were removed
```

Add in the fish that were already measured and the fish there are no cooresponding measured counterparts
```{r}
d.info <- d.info %>%
  dplyr::rename(SpCode = sp_code, Length = fork_length)
# add in measured fish that were used in the loop, but don't appear in the d output dataframe
fish.m.all <- bind_rows(d.info, fish.m)

# add in unmeasured fish that did NOT have a measured counter part and were not included in the loop above
# these are the fish excluded and sockeye salmon 

sal.all <- fish.m.all %>%
  bind_rows(excluded.fish) %>%
  bind_rows(y) %>%
  dplyr::select(-c(X, keep))

# check to make sure we have the same number of salmon we started with (125450, updated 149329)
sal.all$abundance <- as.numeric(ifelse(is.na(sal.all$Length), paste(sal.all$Unmeasured), 1))
sal.all %>%
  dplyr::summarise(sum = sum(abundance)) # woo!

# do an full join, meaning that we're retaining all rows. This should join the salmon sites together and then add in non salmon sites
non_sal <- anti_join(Site_info, sal.all)
fish.all <- full_join(sal.all, non_sal)
```

Okay so now we have a dataframe with information about the salmon that were caught (count numbers) and size (only where measured and where it could be extrapolated). It also has siteID and eventID from all the seines that occured. So we can add in zeros for the sites we didn't catch any salmon. 
BUT because the size info is only partial (salmon weren't measured at every site) Length information should be kept seperate

Create two dataframes, one with abundance one with available length info (so a partial dataset of all the caught fish). 

```{r}
# make sure that abundance column is correct
fish.all$abundance <- as.numeric(ifelse(is.na(fish.all$Length), paste(fish.all$Unmeasured), 1))

fish.count <- fish.all %>%
  dplyr::select(SiteID, EventID, Date, Mon, Year, Gear, Latitude, Longitude, SpCode, Sp_CommonName, 
                Sp_ScientificName, abundance, Locale, Habitat) %>%
  group_by(SiteID, EventID, SpCode) %>%
  dplyr::summarise(abundance = sum(abundance))

# quick checks
fish.all %>%
  dplyr::summarise(post_count = sum(abundance, na.rm = TRUE))

fish_lng <- fish.all %>%
  filter(Length != "NA") # sites where there are no lenght data does NOT mean that no salmon were caught there, just that no salmon were measured there and *might have* been caught. 
```

# Get 0's
For the following purposes we're going to use the `fish.count` dataframe

Calculate 0's for sites no salmon were caught
```{r}
# add back in the site info
fish.counts <- left_join(fish.count, env) %>%
  left_join(loc)

# long --> wide
# This includes ALL species (not just salmon). We'll leave this for now because it matches the
# environmental dataframe. But eventually we'll have to remove the non-salmon species. BUT we want
# retain the 0 where a seine was done but no salmon were caught. 
df_wide <- pivot_wider(fish.counts, id_cols = c(SiteID, EventID, Locale, SubLocale, Date, Year, Latitude, Longitude, Habitat), names_from = SpCode, values_from = abundance) %>%
  dplyr::select(-"NA") %>%
  replace(is.na(.), 0)

# wide -- > long, convserves zeros and site/event ID information

df_long <- pivot_longer(df_wide, cols = c(SALCHIN, SALCOHO, SALPINK, SALCHUM, SALSOCK), names_to = "SpCode", values_to = "abundance")


# REMOVE ALL SEINES WHERE THEY CAUGHT LESS THAN 10 SALMON
# sal_wide <- sal_wide[which(rowSums(sal_wide[,7:11]) > 10),] # this is good to do for nmds analysis
# sal_long <- melt(sal_wide, id = c("SiteID", "EventID", "Date", "Mon", "Season", "Year"), variable.name = "SpCode", value.name = "abundance" )
```

Now we have four dataframes to be working with. 
1. df_wide - salmon abundances for all sites in a wide format
2. df_long - same data as the wide df but long
3. env - environmental data in a wide format
4. loc - location information for each site (included with df_wide and df_long)

# Map
Lets map out the sites so that we can see where the diff sites are location and we can 
```{r map}
# make sure the habitat column is a factor with only 4 levels
fish.counts$Habitat <- as.factor(fish.counts$Habitat)
levels(fish.counts$Habitat)[levels(fish.counts$Habitat)=="Sand-Gravel"] <- "Sand-gravel"
levels(fish.counts$Habitat)[levels(fish.counts$Habitat)=="Surfgrass"] <- "Kelp"

# Prince of Wales Water Polygon
h2o.utm <- readOGR(dsn = "../APECS Master repository/APECS Master repo/ALL_DATA/spatial_data", layer = "POW_water_UTM")
h2o.latlong <- spTransform(h2o.utm, CRS("+init=epsg:4326"))

# Set up icons
icon.hab <- awesomeIcons(icon = "map_pin", 
                          markerColor = ifelse(fish.counts$Habitat == "Kelp", "orange", 
                                               ifelse(fish.counts$Habitat == "Eelgrass", "green",
                                                      ifelse(fish.counts$Habitat == "Bedrock", "gray",
                                                             ifelse(fish.counts$Habitat == "Sand-gravel", "red", "blue")))
                                               ), library = "fa", iconColor = "black")

# Create the map
require(leaflet)
m <- leaflet() %>% 
  addTiles() %>% 
  addPolygons(data = h2o.latlong, stroke = NA, fillColor = "blue", 
                                  fillOpacity = 0.8, group = "POW") %>%
  addAwesomeMarkers(data = fish.counts, ~Longitude, ~Latitude, label = ~SiteID, icon = icon.hab)
# require(htmlwidgets)
# saveWidget(m, file="m.html")
m
```

Based on looking at the map and information about how Johnson et al., 2012 defines southern Southeast Outside there are 8 paired sites that are good comparisons of vegetated versus unvegated habitat. Vegetation either means eelgrass or understory kelp whereas unvegetated means bedrock or sand/gravel. Only *two* sites in Klawock Inlet/Fish Egg area have a sand/gravel - eelgrass comparison. The rest of the 6 sites are bedrock (unveg) versus kelp AND eelgrass.

Additionally, there are a few other "maybe" sites. One site (EventID 573 and 574) is a bedrock-eelgrass comparison on close but seperate islands in the South Wadleigh area. Another maybe site involves a bedrock site (EventID 575) that is located on Wadleigh Island *across* Klawock Inlet from kelp sites (402/403) and eelgrass sites (364/365). 

First lets subset the "all sites data" into just the sites that we can pair so we can check timing of seines. 
# Pair sites
```{r}
# Did the comparison sites happen within the same month/year? 
# One of the "maybe sites from above (EventIDs 575 w/ 402, 403, 364, 365) shouldn't be included because
# the seines in the unveg site happened in June '98 whereas the others happened in July '99. Could do a 
# comparison between eelgrass and kelp but thats it. The other maybe can be included. Drop the bad site

# Also, two of the klawock sites happened in SEPTEMBER. There's no chance of seeing salmon in the nearshore that late in summer, drop 248, 241, 240
# Lets create a list we can subset the data by

EventID_comp <- c(244, 245, 240, 241, 571, 572, 3168, 3170, 3169, 3173, 3172, 3174, 3171, 3181, 3179, 3180, 3177, 3178, 3175, 3176,  3188, 3186, 3187, 3191, 3189, 3190, 573, 574)

# subset the data
fish.count.sub <- subset(fish.counts, EventID %in% EventID_comp)

# but wait what if there were more than one seine at this site?
SiteID_comp <- fish.count.sub$SiteID
fish.sub <- subset(fish.counts, SiteID %in% SiteID_comp) # yea in particular in klawock inlet
# include only the klawock inlet seines that happened in May (EventIDs 244/245 and 236/237)
# create dataframe to antijoin
drop <- fish.sub %>%
  filter(SiteID == "133" & EventID != "244" | 
           SiteID == "134" & EventID != "245"|
           SiteID == "131" & EventID != "236"|
           SiteID == "132" & EventID != "237")

fish.sub <- fish.sub %>%
  anti_join(drop)

# finaaallly lets create a column that pairs the sites
pair.fish <- fish.sub %>%
  group_by(Locale) %>%
  mutate(site_pair = ifelse(Locale %in% "Moira Sound", "Moira Sound", 
                            ifelse(Locale %in% "Nichols Bay", "Nicols Bay", 
                                   ifelse(Locale %in% "Kah Shakes Cove", "Kah Shakes Cove",
                                          ifelse(Locale %in% "Reef Harbor", "Reef Harbor",
                                                 ifelse(Locale %in% "Sylburn Harbor", "Sylburn Harbor", 
                                                        ifelse(Locale %in% "Dall Bay", "Dall Bay",
                                                               ifelse(SubLocale %in% "Ballena Island", "Ballena Island",
                                                                      ifelse(SubLocale %in% c("Clam Island","Wadleigh Island"), "South Wadleigh", "Klawock Inlet")))))))))
```

Okay now that we only have the sites we're for sure interested and we made sure that they were done in the same timeframe (generally within a few days of each other) and that we've paired them by site_pair -- lets do some exploratory analysis of salmon cpue.
# Exploratory graphs
```{r theme settings}
# Creates custom base plot theme that can adjust every graph that you use plot_theme for!

plot_theme <- function() {
  theme_bw(base_size = 14, base_family = "Avenir") %+replace%
    theme(panel.background  = element_blank(),
            plot.background = element_rect(fill="gray96", colour=NA), 
            legend.background = element_rect(fill="transparent", colour=NA),
            legend.key = element_rect(fill="transparent", colour=NA),
            panel.grid.major = element_blank(), 
            panel.grid.minor = element_blank(),
            strip.background = element_rect(colour = "NA", fill = "gray96"))
}

# to use ggsave and export plots include argument 'device=cario_pdf' e.g.: 
# ggsave("name.pdf", device=cairo_pdf, width = 6, height = 6)
```

```{r}
# avg multiple adj sites that occurred in the same hab
require(viridis) # for fun color palette

fish.avg <- pair.fish %>%
  group_by(site_pair, Habitat, SpCode) %>%
  mutate(avg = mean(abundance), sd = sd(abundance)) %>%
  mutate(avg = replace_na(avg, 0), sd = replace_na(sd, 0))
```
## Graph CPUE by habitat
```{r g1}
g1 <- fish.avg %>%
  group_by(SiteID) %>%
  drop_na(SpCode) %>%
  ggplot() +
  geom_bar(mapping = aes(x = Habitat, y = avg, fill = SpCode), 
           position = "dodge", stat = "identity") +
  geom_errorbar(mapping = aes(x = Habitat, ymax = avg+sd, ymin = avg-sd), 
                width = 0, stat = "identity") +
  xlab("Habitat") + ylab("CPUE") + 
  facet_wrap(~site_pair) + 
  plot_theme() +
  geom_text(mapping = aes(x = Habitat, y = avg + 200, group = SpCode,
                          label = format(avg, digits = 1, scientific = FALSE)),
            colour = "black", position = position_dodge(0.9), hjust = 0.7)
  
g1 + scale_fill_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```

Looking at average CPUE of salmon  in vegetated versus unvegetated sites
```{r}
fish.avg %>%
  mutate(Hab_type = ifelse(Habitat %in% c("Bedrock", "Sand-gravel"), "Unvegetated", "Vegetated")) %>%
  group_by(Hab_type) %>%
  ggplot(mapping = aes(x = Hab_type, y = abundance)) +
  geom_boxplot() +
  xlab("Habitat type") + ylab("CPUE") +
  plot_theme()
```

## Graph avg fish per unveg/veg
```{r}
fish.sum <- fish.avg %>%
  drop_na(SpCode) %>%
  mutate(Hab_type = ifelse(Habitat %in% c("Bedrock", "Sand-gravel"), "Unvegetated", "Vegetated")) %>%
  group_by(Hab_type, SpCode) %>%
  dplyr::summarise(avg = mean(abundance), sd = sd(abundance))

g2 <- ggplot(data = fish.sum, aes(x = Hab_type, y = avg, ymin = avg-sd, ymax = avg+sd, fill = SpCode)) +
  geom_bar(position = position_dodge(), aes(y = avg), stat = "identity") +
  geom_errorbar(position = position_dodge(width = 0.9), colour = "black", width = 0.1) +
  xlab("Habitat") + ylab("CPUE") +
  plot_theme()
g2 + scale_fill_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```

## Catch by lat/long
```{r}
g <- sal_env %>%
  drop_na(SpCode) %>%
  ggplot() +
  geom_point(aes(x = Latitude, y = Longitude, size = abundance, shape = Habitat)) +
  plot_theme()
g
```

Theres clearly a lot of variability in salmon catches, but at first glance at the graphs make it look like there isn't a large diff in the number of salmon caught in each hab, maybe with more salmon caught in the unvegetated habitat. 
## Assesing distribution
We've done some basic visualizations above, but lets also look at normality, outliers, collinearity, etc. As well as looking into transformations. 
```{r}

```


Lets use some GLMs to evaluate relationships between salmon catch in habitats

# GLM explorations
## Visualizations
```{r data compilation}
# Need all the salmon data (all sites we've been working with above) and the associated environmental information
# df for salmon : pair.fish
# environmental data are: temp, salinity, julian day, and anadromous stream dist. 
# anadromous distance comes from df anad_dist
anad_dist$SiteID <- as.character(anad_dist$SiteID)
anad_dist$EventID  <- as.character(anad_dist$EventID)

sal_env <- subset(anad_dist, SiteID %in% SiteID_comp) %>%
  replace(is.na(.), 0) %>%
  dplyr::select(SiteID, EventID, Date, NEAR_DIST, Locale, SubLocale.y) %>%
  distinct() %>%
  right_join(pair.fish) %>%
  mutate(date = mdy(Date)) %>%
  mutate(julian = yday(date)) %>%
  mutate(dist_km = NEAR_DIST/100)

# looks like theres a couple sites where we don't have environmental information. 
# No temperature or salinity for: Ballena Island and South Wadleigh (plus no dist info)
```

```{r data structure}
corrgram(sal_env[,c(8, 9:11, 21, 22)], lower.panel = panel.shade,
         upper.panel = panel.cor, diag.panel = panel.density)

# can we seperate the abundances by species to look at possible species based correlations?
sal_env_wide <- pivot_wider(sal_env, names_from = SpCode, values_from = abundance)

corrgram(sal_env_wide[,c(8,9, 19:23)], lower.panel = panel.shade, 
         upper.panel = panel.cor, diag.panel = panel.density)
# Looks like theres a couple explanatory parameters that shouldn't be included together since they're already strongly correlated. Temperature and Julian day
```

```{r}
# Graph species abundance against distance from anad dist
g <- sal_env %>%
  drop_na(SpCode) %>%
  ggplot(aes(x = dist_km, y = abundance, color = SpCode)) + 
  geom_point(size = 2) + 
  plot_theme() +
  ylab("CPUE") + xlab("Distance from anadromous stream (km)")
g3 <- g + scale_color_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```
```{r}
g4 <- sal_env %>%
  drop_na(SpCode) %>%
  ggplot(aes(x = Temp, y = abundance, color = SpCode)) + 
  geom_point(size = 2) + 
  plot_theme() +
  ylab("CPUE") + xlab("Temperature (C)")
g4 <- g4 + scale_color_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```
```{r}
g5 <- sal_env %>%
  drop_na(SpCode) %>%
  ggplot(aes(x = Salinity, y = abundance, color = SpCode)) + 
  geom_point(size = 2) + 
  plot_theme() +
  ylab("CPUE") + xlab("Salinity")
g5 <- g5 + scale_color_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```
```{r}
g6 <- sal_env %>%
  drop_na(SpCode) %>%
  ggplot(aes(x = julian, y = abundance, color = SpCode)) + 
  geom_point(size = 2) + 
  plot_theme() +
  ylab("CPUE") + xlab("Julian day")
g6 <- g6 + scale_color_brewer(name = "Species", labels = c("Chum", "Coho", "Pink"), palette = "Dark2")
```

Arrange the plots together to look at the same time
```{r}
library(cowplot)
plot_grid(g3, g4, g5, g6,
          labels = c("A", "B", "C", "D"),
          ncol = 2, nrow = 2)
```
## Binomial 
Lets first set up some explorations with binomial models to look at presence absence. 
```{r}
sal_env <- sal_env %>%
  replace(is.na(.), 0) %>%
  mutate(Hab_type = ifelse(Habitat %in% c("Bedrock", "Sand-gravel"), "Unvegetated", "Vegetated"))
hist(as.numeric(sal_env$abundance > 0))

plot((abundance > 0) ~ julian, data = sal_env)
plot((abundance > 0) ~ Temp, data = sal_env)
plot((abundance > 0) ~ Salinity, data = sal_env)
plot((abundance > 0) ~ dist_km, data = sal_env)

# convert to 0 & 1 for binomial models
sal_env$binomial[sal_env$abundance > 0] <- 1
sal_env$binomial[sal_env$abundance == 0] <- 0

```

```{r}
# include a model with julian, salinity, habitat w/ interactions
fit1 <- glm(binomial ~ Habitat + julian * I(julian^2)*Salinity * dist_km, family = binomial(link = logit), data = sal_env)
summary(fit1) #... bizarre things are happening -- make sure you have a logical reason for including interaction

# try without interaction
fit2 <- glm(binomial ~ Habitat + julian + I(julian^2) + Salinity + dist_km, family = binomial(link = logit), data = sal_env)
summary(fit2) # no parameters are significant

# look at w/o intx w/ 2 hab types
fit3 <- glm(binomial ~ Hab_type + julian + I(julian^2) + Salinity + dist_km, family = binomial(link = logit), data = sal_env)
summary(fit3)

# check out using temperature rather than julian day
fit4 <- glm(binomial ~ Habitat * Temp * Salinity * dist_km, family = binomial(link = logit), data = sal_env)
summary(fit4) # not ideal

# try w/o intx 
fit5 <- glm(binomial ~ Habitat + Temp + Salinity + dist_km, family = binomial(link = logit), data = sal_env)
summary(fit5)
```

